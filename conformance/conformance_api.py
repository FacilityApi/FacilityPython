"""
DO NOT EDIT: generated by fsdgenpython

ConformanceApi

API for a Facility test server.

The Facility Conformance API allows clients and servers in various languages and platforms
to test one another for conformance.

## Conformance Web Server

A conformance web server should leverage a Facility server code generator and/or library.
On each request, the web server should determine the conformance test being executed by
looking at the `FacilityTest` HTTP header. The web server should find the test data for the
specified test, ensure that the request matches, and return the specified response or error.

The web server should return `InvalidRequest` if:

* The `FacilityTest` HTTP header is missing.
* The API method called does not match the method specified by the test data.
* The actual request is not an exact match of the request specified by the test data.
* The server fails to create a response or error that is an exact match of the specified
  response or error.

When checking for an exact match, the only thing that can be ignored is the order of the
properties of an object. There should be no missing properties, no extra properties, and
all property names and other strings should use the same letter case.

## Conformance Tester

A conformance tester should leverage a Facility client generator and/or library. The tester
should enumerate through all of the conformance tests. For each test, it should create a
client that adds the `FacilityTest` HTTP header to any request. It should use that client to
call the method specified by the test data with the request specified by the test data. The
tester should verify that the result matches the response or error specified by the test data.

The tester should report a test failure if:

* The method specified by the test data is missing.
* The client fails to create a request that is an exact match of the specified request.
* The client receives a response or error that is not an exact match of the specified
  response or error.
"""

import base64
import decimal
import typing

from facilitypython import facility


HTTP_STATUS_CODE_TO_ERROR_CODE = {sc: ec for ec, sc in facility.ERROR_CODE_TO_HTTP_STATUS_CODE.items()}
HTTP_STATUS_CODE_TO_ERROR_CODE[403] = "Forbidden"  # ApiErrors.NotAdmin: The user is not an administrator.
HTTP_STATUS_CODE_TO_ERROR_CODE[500] = "InternalServerError"  # ApiErrors.TooHappy: I'm "too" ðŸ˜„!


class Answer(facility.Enum):
    """
    One of three answers.

    Use `maybe` if you aren't sure.
    """
    YES = "yes"  # Affirmative.
    NO = "no"  # Negative.
    MAYBE = "maybe"  # Unknown.


class Widget(facility.DTO):
    """
    A widget.

    Widgets are useful for conformance tests.
    """
    def __init__(
        self,
        *,
        id_: int = None,
        name: str = None,
    ):
        """
        :param id_: A unique identifier for the widget.
        :param name: The name of the widget.
        """
        super().__init__()
        if not isinstance(id_, (int, type(None))):
            raise ValueError(f"Invalid id_: {id_}")
        self.id_ = id_
        if not isinstance(name, (str, type(None))):
            raise ValueError(f"Invalid name: {name}")
        self.name = name

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "Widget":
        return Widget(
            id_=int(data["id"]) if "id" in data else None,
            name=data.get("name"),
        )


class Any(facility.DTO):
    def __init__(
        self,
        *,
        string: str = None,
        boolean: bool = None,
        double: float = None,
        int32: int = None,
        int64: int = None,
        decimal_: decimal.Decimal = None,
        bytes_: bytes = None,
        object_: object = None,
        error: facility.Error = None,
        data: "Any" = None,
        enum_: "Answer" = None,
        array: "AnyArray" = None,
        map_: "AnyMap" = None,
        result: "AnyResult" = None,
    ):
        """
        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal_:
        :param bytes_:
        :param object_:
        :param error:
        :param data:
        :param enum_:
        :param array:
        :param map_:
        :param result:
        """
        super().__init__()
        if not isinstance(string, (str, type(None))):
            raise ValueError(f"Invalid string: {string}")
        self.string = string
        if not isinstance(boolean, (bool, type(None))):
            raise ValueError(f"Invalid boolean: {boolean}")
        self.boolean = boolean
        if not isinstance(double, (float, type(None))):
            raise ValueError(f"Invalid double: {double}")
        self.double = double
        if not isinstance(int32, (int, type(None))):
            raise ValueError(f"Invalid int32: {int32}")
        self.int32 = int32
        if not isinstance(int64, (int, type(None))):
            raise ValueError(f"Invalid int64: {int64}")
        self.int64 = int64
        if not isinstance(decimal_, (decimal.Decimal, type(None))):
            raise ValueError(f"Invalid decimal_: {decimal_}")
        self.decimal_ = decimal_
        if not isinstance(bytes_, (bytes, type(None))):
            raise ValueError(f"Invalid bytes_: {bytes_}")
        self.bytes_ = bytes_
        if not isinstance(object_, (object, type(None))):
            raise ValueError(f"Invalid object_: {object_}")
        self.object_ = object_
        if not isinstance(error, (facility.Error, type(None))):
            raise ValueError(f"Invalid error: {error}")
        self.error = error
        if not isinstance(data, (Any, type(None))):
            raise ValueError(f"Invalid data: {data}")
        self.data = data
        if not isinstance(enum_, (Answer, type(None))):
            raise ValueError(f"Invalid enum_: {enum_}")
        self.enum_ = enum_
        if not isinstance(array, (AnyArray, type(None))):
            raise ValueError(f"Invalid array: {array}")
        self.array = array
        if not isinstance(map_, (AnyMap, type(None))):
            raise ValueError(f"Invalid map_: {map_}")
        self.map_ = map_
        if not isinstance(result, (AnyResult, type(None))):
            raise ValueError(f"Invalid result: {result}")
        self.result = result

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "Any":
        return Any(
            string=data.get("string"),
            boolean=facility.string_to_bool(data.get("boolean")),
            double=float(data["double"]) if "double" in data else None,
            int32=int(data["int32"]) if "int32" in data else None,
            int64=int(data["int64"]) if "int64" in data else None,
            decimal_=decimal.Decimal(data["decimal"]) if "decimal" in data else None,
            bytes_=base64.b64decode(data["bytes"]) if "bytes" in data else None,
            object_=data.get("object"),
            error=facility.Error.from_data(data["error"]) if "error" in data else None,
            data=Any.from_data(data["data"]) if "data" in data else None,
            enum_=Answer.get(data["enum"]) if "enum" in data else None,
            array=AnyArray.from_data(data["array"]) if "array" in data else None,
            map_=AnyMap.from_data(data["map"]) if "map" in data else None,
            result=AnyResult.from_data(data["result"]) if "result" in data else None,
        )


class AnyArray(facility.DTO):
    def __init__(
        self,
        *,
        string: typing.List[str] = None,
        boolean: typing.List[bool] = None,
        double: typing.List[float] = None,
        int32: typing.List[int] = None,
        int64: typing.List[int] = None,
        decimal_: typing.List[decimal.Decimal] = None,
        bytes_: typing.List[bytes] = None,
        object_: typing.List[object] = None,
        error: typing.List[facility.Error] = None,
        data: typing.List["Any"] = None,
        enum_: typing.List["Answer"] = None,
        array: typing.List[typing.List[int]] = None,
        map_: typing.List[typing.Dict[str, int]] = None,
        result: typing.List[facility.Result[int]] = None,
    ):
        """
        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal_:
        :param bytes_:
        :param object_:
        :param error:
        :param data:
        :param enum_:
        :param array:
        :param map_:
        :param result:
        """
        super().__init__()
        if not isinstance(string, (list, type(None))):
            raise ValueError(f"Invalid string: {string}")
        self.string = string
        if not isinstance(boolean, (list, type(None))):
            raise ValueError(f"Invalid boolean: {boolean}")
        self.boolean = boolean
        if not isinstance(double, (list, type(None))):
            raise ValueError(f"Invalid double: {double}")
        self.double = double
        if not isinstance(int32, (list, type(None))):
            raise ValueError(f"Invalid int32: {int32}")
        self.int32 = int32
        if not isinstance(int64, (list, type(None))):
            raise ValueError(f"Invalid int64: {int64}")
        self.int64 = int64
        if not isinstance(decimal_, (list, type(None))):
            raise ValueError(f"Invalid decimal_: {decimal_}")
        self.decimal_ = decimal_
        if not isinstance(bytes_, (list, type(None))):
            raise ValueError(f"Invalid bytes_: {bytes_}")
        self.bytes_ = bytes_
        if not isinstance(object_, (list, type(None))):
            raise ValueError(f"Invalid object_: {object_}")
        self.object_ = object_
        if not isinstance(error, (list, type(None))):
            raise ValueError(f"Invalid error: {error}")
        self.error = error
        if not isinstance(data, (list, type(None))):
            raise ValueError(f"Invalid data: {data}")
        self.data = data
        if not isinstance(enum_, (list, type(None))):
            raise ValueError(f"Invalid enum_: {enum_}")
        self.enum_ = enum_
        if not isinstance(array, (list, type(None))):
            raise ValueError(f"Invalid array: {array}")
        self.array = array
        if not isinstance(map_, (list, type(None))):
            raise ValueError(f"Invalid map_: {map_}")
        self.map_ = map_
        if not isinstance(result, (list, type(None))):
            raise ValueError(f"Invalid result: {result}")
        self.result = result

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "AnyArray":
        return AnyArray(
            string=[v1 for v1 in data["string"]] if "string" in data else None,
            boolean=[v1 for v1 in data["boolean"]] if "boolean" in data else None,
            double=[float(v1) for v1 in data["double"]] if "double" in data else None,
            int32=[int(v1) for v1 in data["int32"]] if "int32" in data else None,
            int64=[int(v1) for v1 in data["int64"]] if "int64" in data else None,
            decimal_=[decimal.Decimal(v1) for v1 in data["decimal"]] if "decimal" in data else None,
            bytes_=[base64.b64decode(v1) for v1 in data["bytes"]] if "bytes" in data else None,
            object_=[v1 for v1 in data["object"]] if "object" in data else None,
            error=[facility.Error.from_data(v1) for v1 in data["error"]] if "error" in data else None,
            data=[Any.from_data(v1) for v1 in data["data"]] if "data" in data else None,
            enum_=[Answer.get(v1) for v1 in data["enum"]] if "enum" in data else None,
            array=[[int(v2) for v2 in v1] for v1 in data["array"]] if "array" in data else None,
            map_=[v1 for v1 in data["map"]] if "map" in data else None,
            result=[facility.Result.from_data(v1) for v1 in data["result"]] if "result" in data else None,
        )


class AnyMap(facility.DTO):
    def __init__(
        self,
        *,
        string: typing.Dict[str, str] = None,
        boolean: typing.Dict[str, bool] = None,
        double: typing.Dict[str, float] = None,
        int32: typing.Dict[str, int] = None,
        int64: typing.Dict[str, int] = None,
        decimal_: typing.Dict[str, decimal.Decimal] = None,
        bytes_: typing.Dict[str, bytes] = None,
        object_: typing.Dict[str, object] = None,
        error: typing.Dict[str, facility.Error] = None,
        data: typing.Dict[str, "Any"] = None,
        enum_: typing.Dict[str, "Answer"] = None,
        array: typing.Dict[str, typing.List[int]] = None,
        map_: typing.Dict[str, typing.Dict[str, int]] = None,
        result: typing.Dict[str, facility.Result[int]] = None,
    ):
        """
        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal_:
        :param bytes_:
        :param object_:
        :param error:
        :param data:
        :param enum_:
        :param array:
        :param map_:
        :param result:
        """
        super().__init__()
        if not isinstance(string, (dict, type(None))):
            raise ValueError(f"Invalid string: {string}")
        self.string = string
        if not isinstance(boolean, (dict, type(None))):
            raise ValueError(f"Invalid boolean: {boolean}")
        self.boolean = boolean
        if not isinstance(double, (dict, type(None))):
            raise ValueError(f"Invalid double: {double}")
        self.double = double
        if not isinstance(int32, (dict, type(None))):
            raise ValueError(f"Invalid int32: {int32}")
        self.int32 = int32
        if not isinstance(int64, (dict, type(None))):
            raise ValueError(f"Invalid int64: {int64}")
        self.int64 = int64
        if not isinstance(decimal_, (dict, type(None))):
            raise ValueError(f"Invalid decimal_: {decimal_}")
        self.decimal_ = decimal_
        if not isinstance(bytes_, (dict, type(None))):
            raise ValueError(f"Invalid bytes_: {bytes_}")
        self.bytes_ = bytes_
        if not isinstance(object_, (dict, type(None))):
            raise ValueError(f"Invalid object_: {object_}")
        self.object_ = object_
        if not isinstance(error, (dict, type(None))):
            raise ValueError(f"Invalid error: {error}")
        self.error = error
        if not isinstance(data, (dict, type(None))):
            raise ValueError(f"Invalid data: {data}")
        self.data = data
        if not isinstance(enum_, (dict, type(None))):
            raise ValueError(f"Invalid enum_: {enum_}")
        self.enum_ = enum_
        if not isinstance(array, (dict, type(None))):
            raise ValueError(f"Invalid array: {array}")
        self.array = array
        if not isinstance(map_, (dict, type(None))):
            raise ValueError(f"Invalid map_: {map_}")
        self.map_ = map_
        if not isinstance(result, (dict, type(None))):
            raise ValueError(f"Invalid result: {result}")
        self.result = result

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "AnyMap":
        return AnyMap(
            string=data["string"] if "string" in data else None,
            boolean=data["boolean"] if "boolean" in data else None,
            double=data["double"] if "double" in data else None,
            int32=data["int32"] if "int32" in data else None,
            int64=data["int64"] if "int64" in data else None,
            decimal_=data["decimal"] if "decimal" in data else None,
            bytes_=data["bytes"] if "bytes" in data else None,
            object_=data["object"] if "object" in data else None,
            error=data["error"] if "error" in data else None,
            data=data["data"] if "data" in data else None,
            enum_=data["enum"] if "enum" in data else None,
            array=data["array"] if "array" in data else None,
            map_=data["map"] if "map" in data else None,
            result=data["result"] if "result" in data else None,
        )


class AnyResult(facility.DTO):
    def __init__(
        self,
        *,
        string: facility.Result[str] = None,
        boolean: facility.Result[bool] = None,
        double: facility.Result[float] = None,
        int32: facility.Result[int] = None,
        int64: facility.Result[int] = None,
        decimal_: facility.Result[decimal.Decimal] = None,
        bytes_: facility.Result[bytes] = None,
        object_: facility.Result[object] = None,
        error: facility.Result[facility.Error] = None,
        data: facility.Result["Any"] = None,
        enum_: facility.Result["Answer"] = None,
        array: facility.Result[typing.List[int]] = None,
        map_: facility.Result[typing.Dict[str, int]] = None,
        result: facility.Result[facility.Result[int]] = None,
    ):
        """
        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal_:
        :param bytes_:
        :param object_:
        :param error:
        :param data:
        :param enum_:
        :param array:
        :param map_:
        :param result:
        """
        super().__init__()
        if not isinstance(string, (facility.Result, type(None))):
            raise ValueError(f"Invalid string: {string}")
        self.string = string
        if not isinstance(boolean, (facility.Result, type(None))):
            raise ValueError(f"Invalid boolean: {boolean}")
        self.boolean = boolean
        if not isinstance(double, (facility.Result, type(None))):
            raise ValueError(f"Invalid double: {double}")
        self.double = double
        if not isinstance(int32, (facility.Result, type(None))):
            raise ValueError(f"Invalid int32: {int32}")
        self.int32 = int32
        if not isinstance(int64, (facility.Result, type(None))):
            raise ValueError(f"Invalid int64: {int64}")
        self.int64 = int64
        if not isinstance(decimal_, (facility.Result, type(None))):
            raise ValueError(f"Invalid decimal_: {decimal_}")
        self.decimal_ = decimal_
        if not isinstance(bytes_, (facility.Result, type(None))):
            raise ValueError(f"Invalid bytes_: {bytes_}")
        self.bytes_ = bytes_
        if not isinstance(object_, (facility.Result, type(None))):
            raise ValueError(f"Invalid object_: {object_}")
        self.object_ = object_
        if not isinstance(error, (facility.Result, type(None))):
            raise ValueError(f"Invalid error: {error}")
        self.error = error
        if not isinstance(data, (facility.Result, type(None))):
            raise ValueError(f"Invalid data: {data}")
        self.data = data
        if not isinstance(enum_, (facility.Result, type(None))):
            raise ValueError(f"Invalid enum_: {enum_}")
        self.enum_ = enum_
        if not isinstance(array, (facility.Result, type(None))):
            raise ValueError(f"Invalid array: {array}")
        self.array = array
        if not isinstance(map_, (facility.Result, type(None))):
            raise ValueError(f"Invalid map_: {map_}")
        self.map_ = map_
        if not isinstance(result, (facility.Result, type(None))):
            raise ValueError(f"Invalid result: {result}")
        self.result = result

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "AnyResult":
        return AnyResult(
            string=facility.Result.from_data(data["string"]) if "string" in data else None,
            boolean=facility.Result.from_data(data["boolean"]) if "boolean" in data else None,
            double=facility.Result.from_data(data["double"]) if "double" in data else None,
            int32=facility.Result.from_data(data["int32"]) if "int32" in data else None,
            int64=facility.Result.from_data(data["int64"]) if "int64" in data else None,
            decimal_=facility.Result.from_data(data["decimal"]) if "decimal" in data else None,
            bytes_=facility.Result.from_data(data["bytes"]) if "bytes" in data else None,
            object_=facility.Result.from_data(data["object"]) if "object" in data else None,
            error=facility.Result.from_data(data["error"]) if "error" in data else None,
            data=facility.Result.from_data(data["data"]) if "data" in data else None,
            enum_=facility.Result.from_data(data["enum"]) if "enum" in data else None,
            array=facility.Result.from_data(data["array"]) if "array" in data else None,
            map_=facility.Result.from_data(data["map"]) if "map" in data else None,
            result=facility.Result.from_data(data["result"]) if "result" in data else None,
        )


class HasWidget(facility.DTO):
    def __init__(
        self,
        *,
        widget: "Widget" = None,
    ):
        """
        :param widget:
        """
        super().__init__()
        if not isinstance(widget, (Widget, type(None))):
            raise ValueError(f"Invalid widget: {widget}")
        self.widget = widget

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "HasWidget":
        return HasWidget(
            widget=Widget.from_data(data["widget"]) if "widget" in data else None,
        )


class GetApiInfoResponse(facility.Response):
    """
    Gets API information.

    The name of the service should be `ConformanceApi`.
    """
    def __init__(
        self,
        *,
        service: str = None,
        version: str = None,
    ):
        """
        :param service: The name of the service.
        :param version: The version of the service.
        """
        super().__init__()
        if not isinstance(service, (str, type(None))):
            raise ValueError(f"Invalid service: {service}")
        self.service = service
        if not isinstance(version, (str, type(None))):
            raise ValueError(f"Invalid version: {version}")
        self.version = version

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "GetApiInfoResponse":
        return GetApiInfoResponse(
            service=data.get("service"),
            version=data.get("version"),
        )


class GetWidgetsResponse(facility.Response):
    """
    Gets widgets.
    """
    def __init__(
        self,
        *,
        widgets: typing.List["Widget"] = None,
    ):
        """
        :param widgets: The widgets.
        """
        super().__init__()
        if not isinstance(widgets, (list, type(None))):
            raise ValueError(f"Invalid widgets: {widgets}")
        self.widgets = widgets

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "GetWidgetsResponse":
        return GetWidgetsResponse(
            widgets=[Widget.from_data(v1) for v1 in data["widgets"]] if "widgets" in data else None,
        )


class CreateWidgetResponse(facility.Response):
    """
    Creates a new widget.
    """
    def __init__(
        self,
        *,
        widget: "Widget" = None,
        url: str = None,
        e_tag: str = None,
    ):
        """
        :param widget: The created widget.
        :param url: The URL of the created widget.
        :param e_tag: The ETag of the created widget.
        """
        super().__init__()
        if not isinstance(widget, (Widget, type(None))):
            raise ValueError(f"Invalid widget: {widget}")
        self.widget = widget
        if not isinstance(url, (str, type(None))):
            raise ValueError(f"Invalid url: {url}")
        self.url = url
        if not isinstance(e_tag, (str, type(None))):
            raise ValueError(f"Invalid e_tag: {e_tag}")
        self.e_tag = e_tag

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "CreateWidgetResponse":
        return CreateWidgetResponse(
            widget=Widget.from_data(data["widget"]) if "widget" in data else None,
            url=data.get("url"),
            e_tag=data.get("eTag"),
        )


class GetWidgetResponse(facility.Response):
    """
    Gets the specified widget.
    """
    def __init__(
        self,
        *,
        widget: "Widget" = None,
        e_tag: str = None,
        not_modified: bool = None,
    ):
        """
        :param widget: The requested widget.
        :param e_tag: The ETag of the widget.
        :param not_modified: The widget still has the specified ETag.
        """
        super().__init__()
        if not isinstance(widget, (Widget, type(None))):
            raise ValueError(f"Invalid widget: {widget}")
        self.widget = widget
        if not isinstance(e_tag, (str, type(None))):
            raise ValueError(f"Invalid e_tag: {e_tag}")
        self.e_tag = e_tag
        if not isinstance(not_modified, (bool, type(None))):
            raise ValueError(f"Invalid not_modified: {not_modified}")
        self.not_modified = not_modified

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "GetWidgetResponse":
        return GetWidgetResponse(
            widget=Widget.from_data(data["widget"]) if "widget" in data else None,
            e_tag=data.get("eTag"),
            not_modified=facility.string_to_bool(data.get("notModified")),
        )


class DeleteWidgetResponse(facility.Response):
    """
    Deletes the specified widget.
    """
    def __init__(
        self,
        *,
        not_found: bool = None,
        conflict: bool = None,
    ):
        """
        :param not_found: The widget was not found.
        :param conflict: The widget no longer has the specified ETag.
        """
        super().__init__()
        if not isinstance(not_found, (bool, type(None))):
            raise ValueError(f"Invalid not_found: {not_found}")
        self.not_found = not_found
        if not isinstance(conflict, (bool, type(None))):
            raise ValueError(f"Invalid conflict: {conflict}")
        self.conflict = conflict

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "DeleteWidgetResponse":
        return DeleteWidgetResponse(
            not_found=facility.string_to_bool(data.get("notFound")),
            conflict=facility.string_to_bool(data.get("conflict")),
        )


class GetWidgetBatchResponse(facility.Response):
    """
    Gets the specified widgets.
    """
    def __init__(
        self,
        *,
        results: typing.List[facility.Result["Widget"]] = None,
    ):
        """
        :param results: The widget results.
        """
        super().__init__()
        if not isinstance(results, (list, type(None))):
            raise ValueError(f"Invalid results: {results}")
        self.results = results

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "GetWidgetBatchResponse":
        return GetWidgetBatchResponse(
            results=[facility.Result.from_data(v1) for v1 in data["results"]] if "results" in data else None,
        )


class MirrorFieldsResponse(facility.Response):
    def __init__(
        self,
        *,
        field: "Any" = None,
        matrix: typing.List[typing.List[typing.List[float]]] = None,
    ):
        """
        :param field:
        :param matrix:
        """
        super().__init__()
        if not isinstance(field, (Any, type(None))):
            raise ValueError(f"Invalid field: {field}")
        self.field = field
        if not isinstance(matrix, (list, type(None))):
            raise ValueError(f"Invalid matrix: {matrix}")
        self.matrix = matrix

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "MirrorFieldsResponse":
        return MirrorFieldsResponse(
            field=Any.from_data(data["field"]) if "field" in data else None,
            matrix=[[[float(v3) for v3 in v2] for v2 in v1] for v1 in data["matrix"]] if "matrix" in data else None,
        )


class CheckQueryResponse(facility.Response):
    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "CheckQueryResponse":
        return CheckQueryResponse(
        )


class CheckPathResponse(facility.Response):
    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "CheckPathResponse":
        return CheckPathResponse(
        )


class MirrorHeadersResponse(facility.Response):
    def __init__(
        self,
        *,
        string: str = None,
        boolean: bool = None,
        double: float = None,
        int32: int = None,
        int64: int = None,
        decimal_: decimal.Decimal = None,
        enum_: "Answer" = None,
    ):
        """
        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal_:
        :param enum_:
        """
        super().__init__()
        if not isinstance(string, (str, type(None))):
            raise ValueError(f"Invalid string: {string}")
        self.string = string
        if not isinstance(boolean, (bool, type(None))):
            raise ValueError(f"Invalid boolean: {boolean}")
        self.boolean = boolean
        if not isinstance(double, (float, type(None))):
            raise ValueError(f"Invalid double: {double}")
        self.double = double
        if not isinstance(int32, (int, type(None))):
            raise ValueError(f"Invalid int32: {int32}")
        self.int32 = int32
        if not isinstance(int64, (int, type(None))):
            raise ValueError(f"Invalid int64: {int64}")
        self.int64 = int64
        if not isinstance(decimal_, (decimal.Decimal, type(None))):
            raise ValueError(f"Invalid decimal_: {decimal_}")
        self.decimal_ = decimal_
        if not isinstance(enum_, (Answer, type(None))):
            raise ValueError(f"Invalid enum_: {enum_}")
        self.enum_ = enum_

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "MirrorHeadersResponse":
        return MirrorHeadersResponse(
            string=data.get("string"),
            boolean=facility.string_to_bool(data.get("boolean")),
            double=float(data["double"]) if "double" in data else None,
            int32=int(data["int32"]) if "int32" in data else None,
            int64=int(data["int64"]) if "int64" in data else None,
            decimal_=decimal.Decimal(data["decimal"]) if "decimal" in data else None,
            enum_=Answer.get(data["enum"]) if "enum" in data else None,
        )


class MixedResponse(facility.Response):
    def __init__(
        self,
        *,
        header: str = None,
        normal: str = None,
        body: object = None,
        empty: bool = None,
    ):
        """
        :param header:
        :param normal:
        :param body:
        :param empty:
        """
        super().__init__()
        if not isinstance(header, (str, type(None))):
            raise ValueError(f"Invalid header: {header}")
        self.header = header
        if not isinstance(normal, (str, type(None))):
            raise ValueError(f"Invalid normal: {normal}")
        self.normal = normal
        if not isinstance(body, (object, type(None))):
            raise ValueError(f"Invalid body: {body}")
        self.body = body
        if not isinstance(empty, (bool, type(None))):
            raise ValueError(f"Invalid empty: {empty}")
        self.empty = empty

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "MixedResponse":
        return MixedResponse(
            header=data.get("header"),
            normal=data.get("normal"),
            body=data.get("body"),
            empty=facility.string_to_bool(data.get("empty")),
        )


class RequiredResponse(facility.Response):
    def __init__(
        self,
        *,
        normal: str = None,
    ):
        """
        :param normal:
        """
        super().__init__()
        if not isinstance(normal, (str, type(None))):
            raise ValueError(f"Invalid normal: {normal}")
        self.normal = normal

    @classmethod
    def from_data(cls, data: typing.Dict[str, typing.Any]) -> "RequiredResponse":
        return RequiredResponse(
            normal=data.get("normal"),
        )


class Client(facility.ClientBase):
    def __init__(self,
                 base_uri: str = "", *,
                 headers: typing.Optional[typing.Dict[str, str]] = None,
                 oauth: typing.Optional[facility.OAuthSettings] = None,
                 max_retries: int = 0):
        super().__init__(base_uri=base_uri, headers=headers, oauth=oauth, max_retries=max_retries)

    def get_api_info(self) -> facility.Result[GetApiInfoResponse]:
        """
        Gets API information.

        The name of the service should be `ConformanceApi`.
        """
        uri_ = "/"
        query_ = dict()
        request_ = None
        headers_ = None
        response_ = self.send_request("GET", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 200:  # OK
            return facility.Result(
                value=GetApiInfoResponse.from_response(response_))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def get_widgets(
        self, *,
        query: str = None,
    ) -> facility.Result[GetWidgetsResponse]:
        """
        Gets widgets.

        :param query: The query.
        """
        uri_ = "/widgets"
        query_ = dict()
        if query is not None:
            query_["q"] = query
        request_ = None
        headers_ = None
        response_ = self.send_request("GET", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 200:  # OK
            return facility.Result(
                value=GetWidgetsResponse.from_response(response_))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def create_widget(
        self, *,
        widget: "Widget",
    ) -> facility.Result[CreateWidgetResponse]:
        """
        Creates a new widget.

        :param widget: The widget to create.
        """
        if widget is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'widget' is required."))
        uri_ = "/widgets"
        query_ = dict()
        request_ = widget.to_data()
        headers_ = None
        response_ = self.send_request("POST", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 201:  # Created
            return facility.Result(
                value=CreateWidgetResponse.from_response(
                    response_,
                    body="widget",
                    header_map={
                        "Location": "url",
                        "eTag": "eTag",
                    }))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def get_widget(
        self, *,
        id_: int,
        if_not_etag: str = None,
    ) -> facility.Result[GetWidgetResponse]:
        """
        Gets the specified widget.

        :param id_: The widget ID.
        :param if_not_etag: Don't get the widget if it has this ETag.
        """
        if id_ is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'id' is required."))
        uri_ = f"/widgets/{facility.encode(id_)}"
        query_ = dict()
        request_ = None
        headers_ = dict()
        if if_not_etag is not None:
            headers_["If-None-Match"] = str(if_not_etag)
        response_ = self.send_request("GET", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 200:  # OK
            return facility.Result(
                value=GetWidgetResponse.from_response(
                    response_,
                    body="widget",
                    header_map={
                        "eTag": "eTag",
                    }))
        if response_.status_code == 304:  # Not Modified
            return facility.Result(
                value=GetWidgetResponse.from_response(
                    response_,
                    body="notModified",
                    default=True,
                    header_map={
                        "eTag": "eTag",
                    }))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def delete_widget(
        self, *,
        id_: int,
        if_etag: str = None,
    ) -> facility.Result[DeleteWidgetResponse]:
        """
        Deletes the specified widget.

        :param id_: The widget ID.
        :param if_etag: Don't delete the widget unless it has this ETag.
        """
        if id_ is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'id' is required."))
        uri_ = f"/widgets/{facility.encode(id_)}"
        query_ = dict()
        request_ = None
        headers_ = dict()
        if if_etag is not None:
            headers_["If-Match"] = str(if_etag)
        response_ = self.send_request("DELETE", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 204:  # No Content
            return facility.Result(
                value=DeleteWidgetResponse.from_response(response_))
        if response_.status_code == 404:  # Not Found
            return facility.Result(
                value=DeleteWidgetResponse.from_response(
                    response_,
                    body="notFound",
                    default=True))
        if response_.status_code == 409:  # Conflict
            return facility.Result(
                value=DeleteWidgetResponse.from_response(
                    response_,
                    body="conflict",
                    default=True))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def get_widget_batch(
        self, *,
        ids: typing.List[int],
    ) -> facility.Result[GetWidgetBatchResponse]:
        """
        Gets the specified widgets.

        :param ids: The IDs of the widgets to return.
        """
        if ids is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'ids' is required."))
        uri_ = "/widgets/get"
        query_ = dict()
        request_ = [v1 for v1 in ids]
        headers_ = None
        response_ = self.send_request("POST", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 200:  # OK
            return facility.Result(
                value=GetWidgetBatchResponse.from_response(
                    response_,
                    body="results"))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def mirror_fields(
        self, *,
        field: "Any" = None,
        matrix: typing.List[typing.List[typing.List[float]]] = None,
    ) -> facility.Result[MirrorFieldsResponse]:
        """

        :param field:
        :param matrix:
        """
        uri_ = "/mirrorFields"
        query_ = dict()
        request_ = dict()
        if field is not None:
            request_["field"] = field.to_data()
        if matrix is not None:
            request_["matrix"] = [[[v3 for v3 in v2] for v2 in v1] for v1 in matrix]
        headers_ = None
        response_ = self.send_request("POST", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 200:  # OK
            return facility.Result(
                value=MirrorFieldsResponse.from_response(response_))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def check_query(
        self, *,
        string: str = None,
        boolean: bool = None,
        double: float = None,
        int32: int = None,
        int64: int = None,
        decimal_: decimal.Decimal = None,
        enum_: "Answer" = None,
    ) -> facility.Result[CheckQueryResponse]:
        """

        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal_:
        :param enum_:
        """
        uri_ = "/checkQuery"
        query_ = dict()
        if string is not None:
            query_["string"] = string
        if boolean is not None:
            query_["boolean"] = boolean
        if double is not None:
            query_["double"] = double
        if int32 is not None:
            query_["int32"] = int32
        if int64 is not None:
            query_["int64"] = int64
        if decimal_ is not None:
            query_["decimal"] = decimal_
        if enum_ is not None:
            query_["enum"] = enum_
        request_ = None
        headers_ = None
        response_ = self.send_request("GET", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 200:  # OK
            return facility.Result(
                value=CheckQueryResponse.from_response(response_))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def check_path(
        self, *,
        string: str,
        boolean: bool,
        double: float,
        int32: int,
        int64: int,
        decimal_: decimal.Decimal,
        enum_: "Answer",
    ) -> facility.Result[CheckPathResponse]:
        """

        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal_:
        :param enum_:
        """
        if string is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'string' is required."))
        if boolean is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'boolean' is required."))
        if double is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'double' is required."))
        if int32 is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'int32' is required."))
        if int64 is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'int64' is required."))
        if decimal_ is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'decimal' is required."))
        if enum_ is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'enum' is required."))
        uri_ = f"/mirror/{facility.encode(string)}/{facility.encode(boolean)}/{facility.encode(double)}/{facility.encode(int32)}/{facility.encode(int64)}/{facility.encode(decimal_)}/{facility.encode(enum_)}"
        query_ = dict()
        request_ = None
        headers_ = None
        response_ = self.send_request("GET", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 200:  # OK
            return facility.Result(
                value=CheckPathResponse.from_response(response_))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def mirror_headers(
        self, *,
        string: str = None,
        boolean: bool = None,
        double: float = None,
        int32: int = None,
        int64: int = None,
        decimal_: decimal.Decimal = None,
        enum_: "Answer" = None,
    ) -> facility.Result[MirrorHeadersResponse]:
        """

        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal_:
        :param enum_:
        """
        uri_ = "/mirrorHeaders"
        query_ = dict()
        request_ = None
        headers_ = dict()
        if string is not None:
            headers_["string"] = str(string)
        if boolean is not None:
            headers_["boolean"] = str(boolean)
        if double is not None:
            headers_["double"] = str(double)
        if int32 is not None:
            headers_["int32"] = str(int32)
        if int64 is not None:
            headers_["int64"] = str(int64)
        if decimal_ is not None:
            headers_["decimal"] = str(decimal_)
        if enum_ is not None:
            headers_["enum"] = str(enum_)
        response_ = self.send_request("GET", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 200:  # OK
            return facility.Result(
                value=MirrorHeadersResponse.from_response(
                    response_,
                    header_map={
                        "string": "string",
                        "boolean": "boolean",
                        "double": "double",
                        "int32": "int32",
                        "int64": "int64",
                        "decimal": "decimal",
                        "enum": "enum",
                    }))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def mixed(
        self, *,
        path: str,
        header: str = None,
        query: str = None,
        normal: str = None,
    ) -> facility.Result[MixedResponse]:
        """

        :param path:
        :param query:
        :param header:
        :param normal:
        """
        if path is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'path' is required."))
        uri_ = f"/mixed/{facility.encode(path)}"
        query_ = dict()
        if query is not None:
            query_["query"] = query
        request_ = dict()
        if normal is not None:
            request_["normal"] = normal
        headers_ = dict()
        if header is not None:
            headers_["header"] = str(header)
        response_ = self.send_request("POST", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 200:  # OK
            return facility.Result(
                value=MixedResponse.from_response(
                    response_,
                    header_map={
                        "header": "header",
                    }))
        if response_.status_code == 202:  # Accepted
            return facility.Result(
                value=MixedResponse.from_response(
                    response_,
                    body="body",
                    header_map={
                        "header": "header",
                    }))
        if response_.status_code == 204:  # No Content
            return facility.Result(
                value=MixedResponse.from_response(
                    response_,
                    body="empty",
                    default=True,
                    header_map={
                        "header": "header",
                    }))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))

    def required(
        self, *,
        query: str,
        normal: str,
        widget: "Widget" = None,
        widgets: typing.List["Widget"] = None,
        widget_matrix: typing.List[typing.List["Widget"]] = None,
        widget_result: facility.Result["Widget"] = None,
        widget_results: typing.List[facility.Result["Widget"]] = None,
        widget_map: typing.Dict[str, "Widget"] = None,
        has_widget: "HasWidget" = None,
    ) -> facility.Result[RequiredResponse]:
        """

        :param query:
        :param normal:
        :param widget:
        :param widgets:
        :param widget_matrix:
        :param widget_result:
        :param widget_results:
        :param widget_map:
        :param has_widget:
        """
        if query is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'query' is required."))
        if normal is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message=f"'normal' is required."))
        uri_ = "/required"
        if query is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message="'query' is required."))
        query_ = {
            "query": query,
        }
        if normal is None:
            return facility.Result(error=facility.Error(code="InvalidRequest", message="'normal' is required."))
        request_ = {
            "normal": normal,
        }
        if widget is not None:
            request_["widget"] = widget.to_data()
        if widgets is not None:
            request_["widgets"] = [v1.to_data() for v1 in widgets]
        if widget_matrix is not None:
            request_["widgetMatrix"] = [[v2.to_data() for v2 in v1] for v1 in widget_matrix]
        if widget_result is not None:
            request_["widgetResult"] = widget_result.to_data()
        if widget_results is not None:
            request_["widgetResults"] = [v1.to_data() for v1 in widget_results]
        if widget_map is not None:
            request_["widgetMap"] = {k1: v1.to_data() for k1, v1 in widget_map.items()}
        if has_widget is not None:
            request_["hasWidget"] = has_widget.to_data()
        headers_ = None
        response_ = self.send_request("POST", uri_, query=query_, request=request_, headers=headers_)
        if response_.status_code == 200:  # OK
            return facility.Result(
                value=RequiredResponse.from_response(response_))
        return facility.Result(
            error=facility.Error.from_response(response_, HTTP_STATUS_CODE_TO_ERROR_CODE.get(response_.status_code)))


# DO NOT EDIT: generated by fsdgenpython
