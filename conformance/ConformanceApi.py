"""
DO NOT EDIT: generated by fsdgenpython

ConformanceApi

API for a Facility test server.

The Facility Conformance API allows clients and servers in various languages and platforms
to test one another for conformance.

## Conformance Web Server

A conformance web server should leverage a Facility server code generator and/or library.
On each request, the web server should determine the conformance test being executed by
looking at the `FacilityTest` HTTP header. The web server should find the test data for the
specified test, ensure that the request matches, and return the specified response or error.

The web server should return `InvalidRequest` if:

* The `FacilityTest` HTTP header is missing.
* The API method called does not match the method specified by the test data.
* The actual request is not an exact match of the request specified by the test data.
* The server fails to create a response or error that is an exact match of the specified
  response or error.

When checking for an exact match, the only thing that can be ignored is the order of the
properties of an object. There should be no missing properties, no extra properties, and
all property names and other strings should use the same letter case.

## Conformance Tester

A conformance tester should leverage a Facility client generator and/or library. The tester
should enumerate through all of the conformance tests. For each test, it should create a
client that adds the `FacilityTest` HTTP header to any request. It should use that client to
call the method specified by the test data with the request specified by the test data. The
tester should verify that the result matches the response or error specified by the test data.

The tester should report a test failure if:

* The method specified by the test data is missing.
* The client fails to create a request that is an exact match of the specified request.
* The client receives a response or error that is not an exact match of the specified
  response or error.
"""

import facility
from enum import Enum
from decimal import Decimal
from urllib.parse import quote
from typing import Dict, List


class Answer(Enum):
    """
    One of three answers.

    Use `maybe` if you aren't sure.
    """
    YES = 1  # Affirmative.
    NO = 2  # Negative.
    MAYBE = 3  # Unknown.


class Widget(facility.DTO):
    """
    A widget.

    Widgets are useful for conformance tests.
    """
    def __init__(
        self,
        id_: int,
        name: str,
    ):
        """
        :param id_: A unique identifier for the widget.
        :param name: The name of the widget.
        """
        super().__init__()
        if not isinstance(id_, (int, type(None))):
            raise ValueError(f"Invalid id_: {id_}")
        self.id_ = id_
        if not isinstance(name, (str, type(None))):
            raise ValueError(f"Invalid name: {name}")
        self.name = name

    @staticmethod
    def from_data(data: dict) -> "Widget":
        return Widget(
            id_=data.get("id_"),
            name=data.get("name"),
        )


class Any(facility.DTO):
    def __init__(
        self,
        string: str,
        boolean: bool,
        double: float,
        int32: int,
        int64: int,
        decimal: Decimal,
        bytes_: bytes,
        object_: object,
        error: facility.Error,
        data: "Any",
        enum_: Answer,
        array: "AnyArray",
        map_: "AnyMap",
        result: "AnyResult",
    ):
        """
        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal:
        :param bytes_:
        :param object_:
        :param error:
        :param data:
        :param enum_:
        :param array:
        :param map_:
        :param result:
        """
        super().__init__()
        if not isinstance(string, (str, type(None))):
            raise ValueError(f"Invalid string: {string}")
        self.string = string
        if not isinstance(boolean, (bool, type(None))):
            raise ValueError(f"Invalid boolean: {boolean}")
        self.boolean = boolean
        if not isinstance(double, (float, type(None))):
            raise ValueError(f"Invalid double: {double}")
        self.double = double
        if not isinstance(int32, (int, type(None))):
            raise ValueError(f"Invalid int32: {int32}")
        self.int32 = int32
        if not isinstance(int64, (int, type(None))):
            raise ValueError(f"Invalid int64: {int64}")
        self.int64 = int64
        if not isinstance(decimal, (Decimal, type(None))):
            raise ValueError(f"Invalid decimal: {decimal}")
        self.decimal = decimal
        if not isinstance(bytes_, (bytes, type(None))):
            raise ValueError(f"Invalid bytes_: {bytes_}")
        self.bytes_ = bytes_
        if not isinstance(object_, (object, type(None))):
            raise ValueError(f"Invalid object_: {object_}")
        self.object_ = object_
        if not isinstance(error, (facility.Error, type(None))):
            raise ValueError(f"Invalid error: {error}")
        self.error = error
        if not isinstance(data, (Any, type(None))):
            raise ValueError(f"Invalid data: {data}")
        self.data = data
        if not isinstance(enum_, (Answer, type(None))):
            raise ValueError(f"Invalid enum_: {enum_}")
        self.enum_ = enum_
        if not isinstance(array, (AnyArray, type(None))):
            raise ValueError(f"Invalid array: {array}")
        self.array = array
        if not isinstance(map_, (AnyMap, type(None))):
            raise ValueError(f"Invalid map_: {map_}")
        self.map_ = map_
        if not isinstance(result, (AnyResult, type(None))):
            raise ValueError(f"Invalid result: {result}")
        self.result = result

    @staticmethod
    def from_data(data: dict) -> "Any":
        return Any(
            string=data.get("string"),
            boolean=data.get("boolean"),
            double=data.get("double"),
            int32=data.get("int32"),
            int64=data.get("int64"),
            decimal=data.get("decimal"),
            bytes_=data.get("bytes_"),
            object_=data.get("object_"),
            error=data.get("error"),
            data=Any.from_data(data["data"]) if "data" in data else None,
            enum_=data.get("enum_"),
            array=AnyArray.from_data(data["array"]) if "array" in data else None,
            map_=AnyMap.from_data(data["map"]) if "map" in data else None,
            result=AnyResult.from_data(data["result"]) if "result" in data else None,
        )


class AnyArray(facility.DTO):
    def __init__(
        self,
        string: List[str],
        boolean: List[bool],
        double: List[float],
        int32: List[int],
        int64: List[int],
        decimal: List[Decimal],
        bytes_: List[bytes],
        object_: List[object],
        error: List[facility.Error],
        data: List[Any],
        enum_: List[Answer],
        array: List[List[int]],
        map_: List[Dict[str, int]],
        result: List[facility.Result],
    ):
        """
        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal:
        :param bytes_:
        :param object_:
        :param error:
        :param data:
        :param enum_:
        :param array:
        :param map_:
        :param result:
        """
        super().__init__()
        if not isinstance(string, (list, type(None))):
            raise ValueError(f"Invalid string: {string}")
        self.string = string
        if not isinstance(boolean, (list, type(None))):
            raise ValueError(f"Invalid boolean: {boolean}")
        self.boolean = boolean
        if not isinstance(double, (list, type(None))):
            raise ValueError(f"Invalid double: {double}")
        self.double = double
        if not isinstance(int32, (list, type(None))):
            raise ValueError(f"Invalid int32: {int32}")
        self.int32 = int32
        if not isinstance(int64, (list, type(None))):
            raise ValueError(f"Invalid int64: {int64}")
        self.int64 = int64
        if not isinstance(decimal, (list, type(None))):
            raise ValueError(f"Invalid decimal: {decimal}")
        self.decimal = decimal
        if not isinstance(bytes_, (list, type(None))):
            raise ValueError(f"Invalid bytes_: {bytes_}")
        self.bytes_ = bytes_
        if not isinstance(object_, (list, type(None))):
            raise ValueError(f"Invalid object_: {object_}")
        self.object_ = object_
        if not isinstance(error, (list, type(None))):
            raise ValueError(f"Invalid error: {error}")
        self.error = error
        if not isinstance(data, (list, type(None))):
            raise ValueError(f"Invalid data: {data}")
        self.data = data
        if not isinstance(enum_, (list, type(None))):
            raise ValueError(f"Invalid enum_: {enum_}")
        self.enum_ = enum_
        if not isinstance(array, (list, type(None))):
            raise ValueError(f"Invalid array: {array}")
        self.array = array
        if not isinstance(map_, (list, type(None))):
            raise ValueError(f"Invalid map_: {map_}")
        self.map_ = map_
        if not isinstance(result, (list, type(None))):
            raise ValueError(f"Invalid result: {result}")
        self.result = result

    @staticmethod
    def from_data(data: dict) -> "AnyArray":
        return AnyArray(
            string=data.get("string"),
            boolean=data.get("boolean"),
            double=data.get("double"),
            int32=data.get("int32"),
            int64=data.get("int64"),
            decimal=data.get("decimal"),
            bytes_=data.get("bytes_"),
            object_=data.get("object_"),
            error=data.get("error"),
            data=list(map(Any.from_data, data["data"])) if "data" in data else None,
            enum_=data.get("enum_"),
            array=data.get("array"),
            map_=data.get("map_"),
            result=data.get("result"),
        )


class AnyMap(facility.DTO):
    def __init__(
        self,
        string: Dict[str, str],
        boolean: Dict[str, bool],
        double: Dict[str, float],
        int32: Dict[str, int],
        int64: Dict[str, int],
        decimal: Dict[str, Decimal],
        bytes_: Dict[str, bytes],
        object_: Dict[str, object],
        error: Dict[str, facility.Error],
        data: Dict[str, Any],
        enum_: Dict[str, Answer],
        array: Dict[str, List[int]],
        map_: Dict[str, Dict[str, int]],
        result: Dict[str, facility.Result],
    ):
        """
        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal:
        :param bytes_:
        :param object_:
        :param error:
        :param data:
        :param enum_:
        :param array:
        :param map_:
        :param result:
        """
        super().__init__()
        if not isinstance(string, (dict, type(None))):
            raise ValueError(f"Invalid string: {string}")
        self.string = string
        if not isinstance(boolean, (dict, type(None))):
            raise ValueError(f"Invalid boolean: {boolean}")
        self.boolean = boolean
        if not isinstance(double, (dict, type(None))):
            raise ValueError(f"Invalid double: {double}")
        self.double = double
        if not isinstance(int32, (dict, type(None))):
            raise ValueError(f"Invalid int32: {int32}")
        self.int32 = int32
        if not isinstance(int64, (dict, type(None))):
            raise ValueError(f"Invalid int64: {int64}")
        self.int64 = int64
        if not isinstance(decimal, (dict, type(None))):
            raise ValueError(f"Invalid decimal: {decimal}")
        self.decimal = decimal
        if not isinstance(bytes_, (dict, type(None))):
            raise ValueError(f"Invalid bytes_: {bytes_}")
        self.bytes_ = bytes_
        if not isinstance(object_, (dict, type(None))):
            raise ValueError(f"Invalid object_: {object_}")
        self.object_ = object_
        if not isinstance(error, (dict, type(None))):
            raise ValueError(f"Invalid error: {error}")
        self.error = error
        if not isinstance(data, (dict, type(None))):
            raise ValueError(f"Invalid data: {data}")
        self.data = data
        if not isinstance(enum_, (dict, type(None))):
            raise ValueError(f"Invalid enum_: {enum_}")
        self.enum_ = enum_
        if not isinstance(array, (dict, type(None))):
            raise ValueError(f"Invalid array: {array}")
        self.array = array
        if not isinstance(map_, (dict, type(None))):
            raise ValueError(f"Invalid map_: {map_}")
        self.map_ = map_
        if not isinstance(result, (dict, type(None))):
            raise ValueError(f"Invalid result: {result}")
        self.result = result

    @staticmethod
    def from_data(data: dict) -> "AnyMap":
        return AnyMap(
            string=data.get("string"),
            boolean=data.get("boolean"),
            double=data.get("double"),
            int32=data.get("int32"),
            int64=data.get("int64"),
            decimal=data.get("decimal"),
            bytes_=data.get("bytes_"),
            object_=data.get("object_"),
            error=data.get("error"),
            data=data.get("data"),
            enum_=data.get("enum_"),
            array=data.get("array"),
            map_=data.get("map_"),
            result=data.get("result"),
        )


class AnyResult(facility.DTO):
    def __init__(
        self,
        string: facility.Result,
        boolean: facility.Result,
        double: facility.Result,
        int32: facility.Result,
        int64: facility.Result,
        decimal: facility.Result,
        bytes_: facility.Result,
        object_: facility.Result,
        error: facility.Result,
        data: facility.Result,
        enum_: facility.Result,
        array: facility.Result,
        map_: facility.Result,
        result: facility.Result,
    ):
        """
        :param string:
        :param boolean:
        :param double:
        :param int32:
        :param int64:
        :param decimal:
        :param bytes_:
        :param object_:
        :param error:
        :param data:
        :param enum_:
        :param array:
        :param map_:
        :param result:
        """
        super().__init__()
        if not isinstance(string, (facility.Result, type(None))):
            raise ValueError(f"Invalid string: {string}")
        self.string = string
        if not isinstance(boolean, (facility.Result, type(None))):
            raise ValueError(f"Invalid boolean: {boolean}")
        self.boolean = boolean
        if not isinstance(double, (facility.Result, type(None))):
            raise ValueError(f"Invalid double: {double}")
        self.double = double
        if not isinstance(int32, (facility.Result, type(None))):
            raise ValueError(f"Invalid int32: {int32}")
        self.int32 = int32
        if not isinstance(int64, (facility.Result, type(None))):
            raise ValueError(f"Invalid int64: {int64}")
        self.int64 = int64
        if not isinstance(decimal, (facility.Result, type(None))):
            raise ValueError(f"Invalid decimal: {decimal}")
        self.decimal = decimal
        if not isinstance(bytes_, (facility.Result, type(None))):
            raise ValueError(f"Invalid bytes_: {bytes_}")
        self.bytes_ = bytes_
        if not isinstance(object_, (facility.Result, type(None))):
            raise ValueError(f"Invalid object_: {object_}")
        self.object_ = object_
        if not isinstance(error, (facility.Result, type(None))):
            raise ValueError(f"Invalid error: {error}")
        self.error = error
        if not isinstance(data, (facility.Result, type(None))):
            raise ValueError(f"Invalid data: {data}")
        self.data = data
        if not isinstance(enum_, (facility.Result, type(None))):
            raise ValueError(f"Invalid enum_: {enum_}")
        self.enum_ = enum_
        if not isinstance(array, (facility.Result, type(None))):
            raise ValueError(f"Invalid array: {array}")
        self.array = array
        if not isinstance(map_, (facility.Result, type(None))):
            raise ValueError(f"Invalid map_: {map_}")
        self.map_ = map_
        if not isinstance(result, (facility.Result, type(None))):
            raise ValueError(f"Invalid result: {result}")
        self.result = result

    @staticmethod
    def from_data(data: dict) -> "AnyResult":
        return AnyResult(
            string=data.get("string"),
            boolean=data.get("boolean"),
            double=data.get("double"),
            int32=data.get("int32"),
            int64=data.get("int64"),
            decimal=data.get("decimal"),
            bytes_=data.get("bytes_"),
            object_=data.get("object_"),
            error=data.get("error"),
            data=data.get("data"),
            enum_=data.get("enum_"),
            array=data.get("array"),
            map_=data.get("map_"),
            result=data.get("result"),
        )


class HasWidget(facility.DTO):
    def __init__(
        self,
        widget: "Widget",
    ):
        """
        :param widget:
        """
        super().__init__()
        if not isinstance(widget, (Widget, type(None))):
            raise ValueError(f"Invalid widget: {widget}")
        self.widget = widget

    @staticmethod
    def from_data(data: dict) -> "HasWidget":
        return HasWidget(
            widget=Widget.from_data(data["widget"]) if "widget" in data else None,
        )


# DO NOT EDIT: generated by fsdgenpython
